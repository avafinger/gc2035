--- a/drivers/media/video/sunxi-vfe/device/gc2035.c	2016-04-02 14:52:32.000000000 -0300
+++ b/drivers/media/video/sunxi-vfe/device/gc2035.c	2016-04-18 15:10:33.631712737 -0300
@@ -14,16 +14,29 @@
 #include <media/v4l2-mediabus.h>
 #include <linux/io.h>
 
-
 #include "camera.h"
 
+static unsigned int hres = 0;
+module_param(hres, uint, 0);
+MODULE_PARM_DESC(hres,
+"hres=0 (640x480|1280x720|1600x1200 - 15 FPS), hres=1 (800x600|1600x1200 - 10 FPS), hres=2 (320x240|640x480|800x600 - 20 FPS), hres=3 (320x240|352x288|640x480 - 15 FPS) (default=0)");
+
+static unsigned int mclk = 0;
+module_param(mclk, uint, 0);
+MODULE_PARM_DESC(mclk,
+"mclk override (default=0)");
+
+static unsigned int frate = 0;
+module_param(frate, uint, 0);
+MODULE_PARM_DESC(frate,
+"frate override (default=0)");
 
 MODULE_AUTHOR("raymonxiu");
+MODULE_AUTHOR("leonardo lontra");
+MODULE_AUTHOR("@lex");
 MODULE_DESCRIPTION("A low-level driver for GalaxyCore gc2035 sensors");
 MODULE_LICENSE("GPL");
 
-
-
 //for internel driver debug
 #define DEV_DBG_EN   		0
 #if(DEV_DBG_EN == 1)		
@@ -45,10 +58,11 @@ MODULE_LICENSE("GPL");
                         }
 
 //define module timing
-#define MCLK              (24*1000*1000)
+int nMCLK; //              (24*1000*1000)
 #define VREF_POL          V4L2_MBUS_VSYNC_ACTIVE_HIGH
 #define HREF_POL          V4L2_MBUS_HSYNC_ACTIVE_HIGH
 #define CLK_POL           V4L2_MBUS_PCLK_SAMPLE_RISING
+#define REG_CLKRC         0xfa
 #define V4L2_IDENT_SENSOR 0x2035
 
 //define the voltage level of control signal
@@ -67,15 +81,16 @@ MODULE_LICENSE("GPL");
 /*
  * Our nominal (default) frame rate.
  */
-#define SENSOR_FRAME_RATE 8
+int nSENSOR_FRAME_RATE;
 
 
+static struct sensor_win_size *sensor_win_sizes_ptr;
 
 /*
  * The gc2035 sits on i2c with ID 0x78
  */
-#define I2C_ADDR                    0x78   
-#define SENSOR_NAME "gc2035"
+#define I2C_ADDR        0x78   
+#define SENSOR_NAME     "gc2035"
 /*
  * Information we maintain about a known sensor.
  */
@@ -91,20 +106,15 @@ static inline struct sensor_info *to_sta
   return container_of(sd, struct sensor_info, sd);
 }
 
-
-
 /*
  * The default register settings
  *
  */
-/* ----------------------------------- */
-/* comment _640x480_1280x720_ONLY      */
-/* if you want 800x600 and 1600x1200   */
-/* ----------------------------------- */
-#define _640x480_1280x720_ONLY
 
-#ifdef _640x480_1280x720_ONLY
-static struct regval_list sensor_default_regs[] = {
+static struct regval_list *sensor_default_regs_ptr; 
+
+static struct regval_list sensor_default_regs_hres0[] =
+{
 	{0xfe,0x80},
 	{0xfe,0x80},
 	{0xfe,0x80},
@@ -129,8 +139,6 @@ static struct regval_list sensor_default
 	{0xee,0x60},
 	{0xef,0x90},
 
-
-
 	{0x0a,0x00}, //row start
 	{0x0c,0x02}, //col start
 
@@ -187,7 +195,6 @@ static struct regval_list sensor_default
 	{0xfe,0x00},
 
 	///////BLK
-
 	{0x3f,0x00}, //prc close???
 	{0x40,0xa7}, // a7 77
 	{0x42,0x7f},
@@ -619,7 +626,6 @@ static struct regval_list sensor_default
 	{0x82,0x02},//awb_en
 
 	//{0xfe ,0xec}, luma_value
-
 	{0xfe,0x01},
 	{0x1e,0xf1},
 	{0x9c,0x00}, //add abs slope 0x02
@@ -687,8 +693,6 @@ static struct regval_list sensor_default
 	{0x28,0xf7},
 	{0x29,0xff},
 
-
-
 	//y-gamma
 	{0x2b,0x00},
 	{0x2c,0x04},
@@ -766,8 +770,132 @@ static struct regval_list sensor_default
 	{0xfe,0x00},
 	{0xc8,0x55}, 
 };
-#else
-static struct regval_list sensor_default_regs[] = {
+
+/* 1600X1200 UXGA capture */
+static struct regval_list sensor_uxga_regs_hres0[] =
+{
+	{0xfe , 0x00},
+	{0x0a , 0x00}, //row start
+	{0x0c , 0x00}, //col start
+
+	{0x0d , 0x04},
+	{0x0e , 0xc0},
+	{0x0f , 0x06}, //Window setting
+	{0x10 , 0x58},// 
+
+	{0x90 , 0x01},  //crop enable
+	{0x94 , 0x04},//add
+	{0x95 , 0x04},
+	{0x96 , 0xb0},
+	{0x97 , 0x06},
+	{0x98 , 0x40},
+	{0x99 , 0x11},
+	{0xc8 , 0x00},
+ 
+	{0xfa , 0x11},
+	
+	{0xfe , 0x03},
+	{0x42 , 0x80}, 
+	{0x43 , 0x06}, //output buf width
+	{0x41 , 0x00}, // delay
+	{0x40 , 0x00}, //fifo half full trig
+	{0x17 , 0x01}, //widv 
+	{0xfe , 0x00},
+	{0xc8 , 0x00},
+};
+
+/* 640X480 VGA */
+static struct regval_list sensor_vga_regs_hres0[] =
+{
+	{0xfe , 0x00},
+
+	{0x0a , 0x00}, //row start
+	{0x0c , 0x00}, //col start
+
+	{0x0d , 0x04},
+	{0x0e , 0xc0},
+	{0x0f , 0x06}, //Window setting
+	{0x10 , 0x58},// 
+	
+	{0x90 , 0x01},
+	{0x94 , 0x00},
+	{0x95 , 0x01},
+	{0x96 , 0xe0},
+	{0x97 , 0x02},
+	{0x98 , 0x80},
+	{0xc8 , 0x15},
+
+	{0xfa , 0x00}, 
+
+	{0xfe , 0x03},
+	{0x42 , 0x00}, 
+	{0x43 , 0x05}, //output buf width  280*2=500
+	{0x41 , 0x02}, // delay
+	{0x40 , 0x40}, //fifo half full trig
+	{0x17 , 0x00}, //widv is 0
+
+	{0xfe , 0x00},
+	{0xc8 , 0x55}, 
+	{0xb6 , 0x03},//aec on
+};
+
+
+/* 1280X720 720HD */
+static struct regval_list Gc2015_sensor_hd720_regs_hres0[] = 
+{
+{0xfe , 0x00},
+{0x05, 0x01},
+{0x06, 0x9e},
+{0x07, 0x01},
+{0x08, 0x6d},  
+{0x0a , 0xf0}, //row start
+{0x0c , 0xa0}, //col start 
+{0x0d , 0x02},
+{0x0e , 0xd8},
+{0x0f , 0x05}, //Window setting
+{0x10 , 0x18},   
+
+{0xfe, 0x01},
+{0x27, 0x00},
+{0x28, 0xd9},
+{0x29, 0x04},
+{0x2a, 0x3d},//18fps
+{0x2b, 0x06},
+{0x2c, 0xc8},//12.5fps
+{0x2d, 0x0a},
+{0x2e, 0x2c},//8fps
+{0x3e, 0x40},//0x40 0x00
+
+//measure window
+{0xfe, 0x00},
+{0xec, 0x04},
+{0xed, 0x04},
+{0xee, 0x50},
+{0xef, 0x58},
+
+{0x90 , 0x01},  //crop enable
+{0x95 , 0x02},
+{0x96 , 0xd0},
+{0x97 , 0x05},
+{0x98 , 0x00},   
+
+{0xfe , 0x03},
+{0x42 , 0x80}, 
+{0x43 , 0x06}, //output buf width
+{0x41 , 0x00}, // delay
+{0x40 , 0x00}, //fifo half full trig
+{0x17 , 0x01}, //widv 
+{0xfe , 0x00},
+{0x99, 0x11},
+{0xc8, 0x00},
+{0xfa, 0x11},
+{0xff, 0xff},
+
+};
+
+
+
+static struct regval_list sensor_default_regs_hres1[] = {
 {0xfe , 0x80},
 {0xfe , 0x80},
 {0xfe , 0x80},  
@@ -806,8 +934,6 @@ static struct regval_list sensor_default
 {0x0f , 0x06}, //Window setting
 {0x10 , 0x58}, 
 {0x17 , 0x14}, //[0]mirror [1]flip
-
-
 {0x18 , 0x0a}, //0a 2012.10.26
 {0x19 , 0x0a}, //AD pipe number
 
@@ -832,7 +958,6 @@ static struct regval_list sensor_default
 {0x13 , 0x75},//y_target
 {0xfe , 0x00},
 
-
 {0x05 , 0x01},//hb
 {0x06 , 0x11},
 {0x07 , 0x00},//vb
@@ -1440,14 +1565,14 @@ static struct regval_list sensor_default
 {0x46 , 0x14},
 {0x47 , 0x09},
 {0xfe , 0x00},
-
 #endif
+
 };
-#endif
 
-/* 1600X1200 UXGA capture */
-static struct regval_list sensor_uxga_regs[] ={
 
+/* 1600X1200 UXGA capture */
+static struct regval_list sensor_uxga_regs_hres1[] =
+{
 {0xfe , 0x00},
 {0xfa , 0x11},
 {0xc8 , 0x00},
@@ -1468,11 +1593,10 @@ static struct regval_list sensor_uxga_re
 {0x96 , 0xb0},  
 {0x97 , 0x06},
 {0x98 , 0x40},
-
 };
 
 /* 800X600 SVGA,30fps*/
-static struct regval_list sensor_svga_regs[] =
+static struct regval_list sensor_svga_regs_hres1[] =
 {
 {0xfe,0x00},
 {0xb6,0x03},
@@ -1497,103 +1621,1609 @@ static struct regval_list sensor_svga_re
 {0x98,0x20},
 };
 
-/* 640X480 VGA */
-static struct regval_list sensor_vga_regs[] =
+
+static struct regval_list sensor_default_regs_hres2[] =
 {
-	{0xfe , 0x00},
+{0xfe , 0x80},
+{0xfe , 0x80},
+{0xfe , 0x80},  
+{0xfc , 0x06},
+{0xf2 , 0x00},
+{0xf3 , 0x00},
+{0xf4 , 0x00},
+{0xf5 , 0x00},
+{0xf9 , 0xfe}, //[0] pll enable
+{0xfa , 0x00},
+{0xf6 , 0x00},
+{0xf7 , 0x15}, //pll enable
 
-	{0x0a , 0x00}, //row start
-	{0x0c , 0x00}, //col start
+{0xf8 , 0x85},
 
-	{0x0d , 0x04},
-	{0x0e , 0xc0},
-	{0x0f , 0x06}, //Window setting
-	{0x10 , 0x58},// 
-	
-	{0x90 , 0x01},
-	{0x94 , 0x00},
-	{0x95 , 0x01},
-	{0x96 , 0xe0},
-	{0x97 , 0x02},
-	{0x98 , 0x80},
-	{0xc8 , 0x15},
+{0xfe , 0x00},
+{0x82 , 0x00}, //00
+{0xb3 , 0x60}, //60
+{0xb4 , 0x40}, //60 40
+{0xb5 , 0x60}, //60
+
+{0x03 , 0x02},
+{0x04 , 0x80},
+
+//////////measure window  ///////////
+{0xfe , 0x00},
+{0xec , 0x06},//04 
+{0xed , 0x06},//04 
+{0xee , 0x62},//60 
+{0xef , 0x92},//90 
+
+///////////analog/////////////
+{0x0a , 0x00}, //row start
+{0x0b , 0x10}, //row start
+{0x0c , 0x00}, //col start
+{0x0d , 0x04}, //4d0 = 1232
+{0x0e , 0xe0}, //d0/b0/d0/c0
+{0x0f , 0x06}, //Window setting
+{0x10 , 0x58}, //40/50/58
+{0x17 , 0x14}, //[0]mirror [1]flip [4]better colour
+
+
+//{0x18 , 0x0a}, //0a 2012.10.26
+{0x18 , 0x0f}, //0a 2012.10.26
+{0x19 , 0x0a}, //AD pipe number
+
+{0x1a , 0x01}, //CISCTL mode4
+{0x1b , 0x8b},
+{0x1c , 0x05}, //added
+{0x1e , 0x88}, //analog mode1 [7] tx-high en [5:3]COL_bias
+{0x1f , 0x08}, //[3] tx-low en//
+{0x20 , 0x05}, //[0]adclk mode , 0x[1]rowclk_MODE [2]rsthigh_en
+{0x21 , 0x0f}, //[6:4]rsg
+{0x22 , 0xf0}, //[3:0]vref   0xf0
+{0x23 , 0xc3}, //f3//ADC_r
+{0x24 , 0x17}, //pad drive <=36MHz, use 0x00 is ok
+
+//AEC
+{0xfe , 0x01},
+{0x11 , 0x20},//20 AEC_out_slope , 0x
+{0x1f , 0xc0},//80 max_post_gain
+{0x20 , 0x60},//40 max_pre_gain
+{0x47 , 0x80},//30 AEC_outdoor_th
+{0x0b , 0x13},//10
+{0x13 , 0x75},//y_target
+{0xfe , 0x00},
+
+{0xfe , 0x00},
+{0xfe , 0x00},
+{0x05 , 0x01},//hb
+{0x06 , 0x0d},
+{0x07 , 0x00},//vb
+{0x08 , 0x40},
+
+{0xfe , 0x01},
+{0x27 , 0x00},//step
+{0x28 , 0xa0},//a0
+{0x29 , 0x05},//  level 0 12.5
+{0x2a , 0x00},
+{0x2b , 0x05},//  level 1 12.5
+{0x2c , 0x00},
+{0x2d , 0x05},//  level 2 12.5 640/10fps
+{0x2e , 0x00},
+{0x2f , 0x08},//  level 3 7.5
+{0x30 , 0x20},
+
+{0xfe , 0x00},
+{0xfe , 0x00},  //0x , 0x , 0x , 0x , 0x 
+{0xb6 , 0x03}, //AEC enable
+{0xfe , 0x00},
+
+/////////BLK//////
+{0x3f, 0x00}, //prc close
+{0x40, 0x77},//
+{0x42, 0x7f},
+{0x43, 0x30},
+{0x5c, 0x08},
+{0x5e, 0x20},
+{0x5f, 0x20},
+{0x60, 0x20},
+{0x61, 0x20},
+{0x62, 0x20},
+{0x63, 0x20},
+{0x64, 0x20},
+{0x65, 0x20},
+
+///block////////////
+{0x80 , 0xff},
+{0x81 , 0x26},//38 , 0x//skin_Y 8c_debug
+{0x87 , 0x90}, //[7]middle gamma 
+{0x84 , 0x02}, //output put foramat
+{0x86 , 0x07}, //02 //sync plority 
+{0x8b , 0xbc},
+{0xb0 , 0x80}, //globle gain
+{0xc0 , 0x40},//Yuv bypass
+
+//////lsc/////////////
+{0xfe,0x01},
+{0xc2,0x21},
+{0xc3,0x1a},
+{0xc4,0x13},
+{0xc8,0x17},
+{0xc9,0x0f},
+{0xca,0x00},
+{0xbc,0x36},
+{0xbd,0x2b},
+{0xbe,0x17},
+{0xb6,0x39},
+{0xb7,0x21},
+{0xb8,0x1c},
+{0xc5,0x00},
+{0xc6,0x00},
+{0xc7,0x00},
+{0xcb,0x00},
+{0xcc,0x0c},
+{0xcd,0x15},
+{0xbf,0x00},
+{0xc0,0x00},
+{0xc1,0x00},
+{0xb9,0x00},
+{0xba,0x00},
+{0xbb,0x00},
+{0xaa,0x15},
+{0xab,0x15},
+{0xac,0x15},
+{0xad,0x14},
+{0xae,0x13},
+{0xaf,0x12},
+{0xb0,0x1b},
+{0xb1,0x14},
+{0xb2,0x14},
+{0xb3,0x1f},
+{0xb4,0x12},
+{0xb5,0x13},
+{0xd0,0x00},
+{0xd2,0x00},
+{0xd3,0x0c},
+{0xd8,0x00},
+{0xda,0x00},
+{0xdb,0x13},
+{0xdc,0x00},
+{0xde,0x00},
+{0xdf,0x25},
+{0xd4,0x00},
+{0xd6,0x00},
+{0xd7,0x12},
+{0xa4,0x00},
+{0xa5,0x00},
+{0xa6,0x00},
+{0xa7,0x00},
+{0xa8,0x00},
+{0xa9,0x00},
+{0xa1,0x80},
+{0xa2,0x80},
+
+//////////cc//////////////
+{0xfe , 0x02},
+{0xc0 , 0x01},
+{0xc1 , 0x40}, //Green_cc for d
+{0xc2 , 0xfc},
+{0xc3 , 0x05},
+{0xc4 , 0xec},
+{0xc5 , 0x42},
+{0xc6 , 0xf8},
+{0xc7 , 0x40},//for cwf 
+{0xc8 , 0xf8},
+{0xc9 , 0x06},
+{0xca , 0xfd},
+{0xcb , 0x3e},
+{0xcc , 0xf3},
+{0xcd , 0x36},//for A
+{0xce , 0xf6},
+{0xcf , 0x04},
+{0xe3 , 0x0c},
+{0xe4 , 0x44},
+{0xe5 , 0xe5},
+{0xfe , 0x00},
 
+///////awb start ////////////////
+//AWB clear
+{0xfe , 0x01},
+{0x4f , 0x00},
+{0x4d , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0x10}, // 10
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0x20}, // 20
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0x30},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00}, // 30
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0x40}, // 40
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0x50}, // 50
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0x60}, // 60
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0x70}, // 70
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0x80}, // 80
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0x90}, // 90
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0xa0}, // a0
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0xb0}, // b0
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0xc0}, // c0
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4d , 0xd0}, // d0
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4e , 0x00},
+{0x4f , 0x01},
+/////// awb value////////
+{0xfe , 0x01},
+{0x4f , 0x00},
+{0x4d , 0x30},
+{0x4e , 0x00},
+{0x4e , 0x80},
+{0x4e , 0x80},
+{0x4e , 0x02},
+{0x4e , 0x02},
+{0x4d , 0x40},
+{0x4e , 0x00},
+{0x4e , 0x80},
+{0x4e , 0x80},
+{0x4e , 0x02},
+{0x4e , 0x02},
+{0x4e , 0x02},
+{0x4d , 0x53},
+{0x4e , 0x08},
+{0x4e , 0x04},
+{0x4d , 0x62},
+{0x4e , 0x10},
+{0x4d , 0x72},
+{0x4e , 0x20},
+{0x4f , 0x01},
+
+/////awb////
+{0xfe , 0x01},
+{0x50 , 0x88},//c0//[6]green mode
+{0x52 , 0x40},
+{0x54 , 0x60},
+{0x56 , 0x06},
+{0x57 , 0x20}, //pre adjust
+{0x58 , 0x01}, 
+{0x5b , 0x02}, //AWB_gain_delta
+{0x61 , 0xaa},//R/G stand
+{0x62 , 0xaa},//R/G stand
+{0x71 , 0x00},
+{0x74 , 0x10},  //0x//AWB_C_max
+{0x77 , 0x08}, // 0x//AWB_p2_x
+{0x78 , 0xfd}, //AWB_p2_y
+{0x86 , 0x30},
+{0x87 , 0x00},
+{0x88 , 0x04},//06 , 0x//[1]dark mode
+{0x8a , 0xc0},//awb move mode
+{0x89 , 0x75},
+{0x84 , 0x08},  //0x//auto_window
+{0x8b , 0x00}, // 0x//awb compare luma
+{0x8d , 0x70}, //awb gain limit R 
+{0x8e , 0x70},//G
+{0x8f , 0xf4},//B
+{0xfe , 0x00},
+{0x82 , 0x02},//awb_en
+/////////awb end /////////////
+
+///==========asde
+{0xfe, 0x01},
+{0x21, 0xbf},
+{0xfe, 0x02},
+{0xa4, 0x00},//
+{0xa5, 0x40}, //lsc_th
+{0xa2, 0xa0}, //lsc_dec_slope
+{0x86, 0x27},//add for DPC travis 20140505   
+{0x8a, 0x33},//add for DPC travis 20140505 
+{0x8d, 0x85},//add for DPC travis 20140505 
+{0xa6, 0xf0},//80//change for DPC travis 20140505
+{0xa7, 0x80}, //ot_th
+{0xab, 0x31}, //
+{0xa9, 0x6f}, //
+{0xb0, 0x99}, //0x//edge effect slope low
+{0xb1, 0x34},//edge effect slope low
+{0xb3, 0x80}, //saturation dec slope
+{0xde, 0xb6},  //
+{0x38, 0x0f}, // 
+{0x39, 0x60}, //
+{0xfe, 0x00},
+{0x81, 0x26},
+{0xfe, 0x02},
+{0x83, 0x00},//
+{0x84, 0x45},//
+////////////YCP//////////
+{0xd1 , 0x34},//saturation_cb
+{0xd2 , 0x34},//saturation_Cr
+{0xd3 , 0x40},//contrast ?	{0xd4 , 0x80},//contrast center 
+{0xd4  , 0x80},//contrast center 
+{0xd5 , 0x00},//luma_offset 
+{0xdc , 0x30},
+{0xdd , 0xb8},//edge_sa_g,b
+{0xfe , 0x00},
+///////dndd///////////
+{0xfe , 0x02},
+{0x88 , 0x15},//dn_b_base
+{0x8c , 0xf6}, //[2]b_in_dark_inc
+{0x89 , 0x03}, //dn_c_weight
+////////EE ///////////
+{0xfe , 0x02},
+{0x90 , 0x6c},// EEINTP mode1
+{0x97 , 0x45},// edge effect
+////==============RGB Gamma 
+{0xfe , 0x02},
+{0x15 , 0x0a},
+{0x16 , 0x12},
+{0x17 , 0x19},
+{0x18 , 0x1f},
+{0x19 , 0x2c},
+{0x1a , 0x38},
+{0x1b , 0x42},
+{0x1c , 0x4e},
+{0x1d , 0x63},
+{0x1e , 0x76},
+{0x1f , 0x87},
+{0x20 , 0x96},
+{0x21 , 0xa2},
+{0x22 , 0xb8},
+{0x23 , 0xca},
+{0x24 , 0xd8},
+{0x25 , 0xe3},
+{0x26 , 0xf0},
+{0x27 , 0xf8},
+{0x28 , 0xfd},
+{0x29 , 0xff},
+
+///=================y gamma
+{0xfe , 0x02},
+{0x2b , 0x00},
+{0x2c , 0x04},
+{0x2d , 0x09},
+{0x2e , 0x18},
+{0x2f , 0x27},
+{0x30 , 0x37},
+{0x31 , 0x49},
+{0x32 , 0x5c},
+{0x33 , 0x7e},
+{0x34 , 0xa0},
+{0x35 , 0xc0},
+{0x36 , 0xe0},
+{0x37 , 0xff},
+/////1600x1200size// 
+{0xfe, 0x00},//
+{0x90, 0x01}, //0x//crop enable
+{0x94, 0x04},
+{0x95, 0x04},  //0x//1600x1200
+{0x96, 0xb0},
+{0x97, 0x06},
+{0x98, 0x40},
+
+{0xfe , 0x03},
+{0x40 , 0x40},  //00
+{0x41 , 0x02}, // Pclk_polarity 
+{0x42 , 0x40}, 
+{0x43 , 0x06}, //output buf width 
+{0x17 , 0x01}, //widv 
+{0xfe , 0x00},
+
+////output DVP/////
+{0xfe  , 0x00},
+{0x82  , 0xfe},  // fe
+{0xf2  , 0x70}, 
+{0xf3  , 0xff},
+{0xf4  , 0x00},
+{0xf5  , 0x30},
+
+#if 1   
+/////////  re zao///
+{0xfe  , 0x00},
+{0x22  , 0xf0},
+{0xfe  , 0x01},
+{0x21  , 0xff},
+{0xfe  , 0x02},  
+{0x8a  , 0x33},
+{0x8c  , 0x76},
+{0x8d  , 0x85},
+{0xa6  , 0xf0},	
+{0xae  , 0x9f},
+{0xa2  , 0x90},
+{0xa5  , 0x40},  
+{0xa7  , 0x30},
+{0xb0  , 0x88},
+{0x38  , 0x0b},
+{0x39  , 0x30},
+{0xfe  , 0x00},
+
+{0x87  , 0xb0},
+
+//// small  RGB gamma////
+/*
+{0xfe , 0x02},
+{0x15 , 0x0b},
+{0x16 , 0x0e},
+{0x17 , 0x10},
+{0x18 , 0x12},
+{0x19 , 0x19},
+{0x1a , 0x21},
+{0x1b , 0x29},
+{0x1c , 0x31},
+{0x1d , 0x41},
+{0x1e , 0x50},
+{0x1f , 0x5f},
+{0x20 , 0x6d},
+{0x21 , 0x79},
+{0x22 , 0x91},
+{0x23 , 0xa5},
+{0x24 , 0xb9},
+{0x25 , 0xc9},
+{0x26 , 0xe1},
+{0x27 , 0xee},
+{0x28 , 0xf7},
+{0x29 , 0xff},
+*/
+////dark sun/////
+{0xfe , 0x02},
+{0x40 , 0x06},
+{0x41 , 0x23},
+{0x42 , 0x3f},
+{0x43 , 0x06},
+{0x44 , 0x00},
+{0x45 , 0x00},
+{0x46 , 0x14},
+{0x47 , 0x09},
+{0xfe , 0x00},
+#endif
+
+};
+
+/* 1600X1200 UXGA capture */
+static struct regval_list sensor_uxga_regs_hres2[] =
+{
+{0xfe , 0x00},
+{0xfa , 0x11},
+{0xc8 , 0x00},
+
+{0x99 , 0x11},// 1/2 subsample
+{0x9a , 0x06},
+{0x9b , 0x00},
+{0x9c , 0x00},
+{0x9d , 0x00},
+{0x9e , 0x00},
+{0x9f , 0x00},
+{0xa0 , 0x00},  
+{0xa1 , 0x00},
+{0xa2 , 0x00},
+
+{0x90 , 0x01},
+{0x95 , 0x04},
+{0x96 , 0xb0},  
+{0x97 , 0x06},
+{0x98 , 0x40},
+
+};
+
+/* 800X600 SVGA,20fps*/
+static struct regval_list sensor_svga_regs_hres2[] =
+{
+{0xfe,0x00},
+{0xb6,0x03},
+{0xfa,0x00},
+{0xc8,0x00},//close scaler
+
+{0x99,0x22},// 1/2 subsample
+{0x9a,0x07},
+{0x9b,0x00},
+{0x9c,0x00},
+{0x9d,0x00},
+{0x9e,0x00},
+{0x9f,0x00},
+{0xa0,0x00},  
+{0xa1,0x00},
+{0xa2,0x00},
+
+{0x90,0x01},  //crop enable
+{0x95,0x02},
+{0x96,0x58},
+{0x97,0x03},
+{0x98,0x20},
+};
+
+/* 640x480 VGA,20fps*/
+static struct regval_list sensor_vga_regs_hres2[] =
+{
+{0xfe,0x00},
+{0xb6,0x03},
+{0xfa,0x00},
+{0xc8,0x02}, //close scaler 
+
+{0x99,0x22},// 1/2 subsample
+{0x9a,0x06},
+{0x9b,0x00},
+{0x9c,0x00},
+{0x9d,0x00},
+{0x9e,0x00},
+{0x9f,0x00},
+{0xa0,0x00},  
+{0xa1,0x00},
+{0xa2,0x00},
+
+{0x90,0x01},  //crop enable
+{0x95,0x02},
+{0x96,0x58},
+{0x97,0x03},
+{0x98,0x20},
+};
+
+/* 320x240 QVGA,20fps*/
+static struct regval_list sensor_qvga_regs_hres2[] =
+{
+{0xfe,0x00},
+{0xb6,0x03},
+{0xfa,0x00},
+{0xc8,0x02}, //close scaler 
+
+{0x99,0x44},// 1/2 subsample
+{0x9a,0x06},
+{0x9b,0x00},
+{0x9c,0x00},
+{0x9d,0x00},
+{0x9e,0x00},
+{0x9f,0x00},
+{0xa0,0x00},  
+{0xa1,0x00},
+{0xa2,0x00},
+
+{0x90,0x01},  //crop enable
+{0x95,0x02},
+{0x96,0x58},
+{0x97,0x03},
+{0x98,0x20},
+};
+
+#if 1
+static struct regval_list sensor_default_regs_hres3[] =
+{
+	{0xfe, 0x80},
+	{0xfe, 0x80},
+	{0xfe, 0x80},
+	{0xfc, 0x06},
+	{0xf2, 0x00},
+	{0xf3, 0x00},
+	{0xf4, 0x00},
+	{0xf5, 0x00},
+	{0xf9, 0xfe}, //[0] pll enable
+	{0xfa, 0x00},
+	{0xf6, 0x00},
+	{0xf7, 0x15}, //pll enable
+    #if 1
+	{0xf8, 0x85},
+	#else
+	{0xf8, 0x84},
+	#endif
+	{0xfe, 0x00},
+	{0x82, 0x00},
+	{0xb3, 0x60},
+	{0xb4, 0x40},
+	{0xb5, 0x60},
+
+	#if 1
+	{0x03 , 0x02},
+	{0x04 , 0x80},
+	#else
+	{0x03, 0x04},
+	{0x04, 0x9b},
+	#endif
+	//////////measure window  ///////////
+	{0xfe, 0x00},
+	{0xec, 0x06},//04 
+	{0xed, 0x06},//04 
+	{0xee, 0x62},//60 
+	{0xef, 0x92},//90 
+	
+	///////////analog/////////////
+	{0x0a, 0x00}, //row start
+	{0x0c, 0x00}, //col start
+	{0x0d, 0x04},
+	{0x0e, 0xc0},
+	{0x0f, 0x06}, //Window setting
+	{0x10, 0x58}, 
+	{0x17, 0x14}, //[0]mirror [1]flip
+
+
+	{0x18, 0x0e}, //sdark 4 row in even frame??
+	{0x19, 0x0c}, //AD pipe number
+
+	/*
+	///  Ã«´Ì ÏÖÏó
+	{0x18,0x0a}, //sdark 4 row in even frame??
+	{0x19,0x0a}, //AD pipe number
+	*/
+	
+	{0x1a , 0x01}, //CISCTL mode4
+	{0x1b , 0x8b},
+	{0x1c , 0x05},
+	{0x1e , 0x88}, //analog mode1 [7] tx-high en [5:3]COL_bias
+	{0x1f , 0x08}, //[3] tx-low en//
+	{0x20 , 0x05}, //[0]adclk mode , 0x[1]rowclk_MODE [2]rsthigh_en
+	{0x21 , 0x0f}, //[6:4]rsg
+	{0x22 , 0xf0}, //[3:0]vref
+	{0x23 , 0xc3}, //f3//ADC_r
+	{0x24 , 0x17}, //pad drive  16
+
+	//AEC
+	{0xfe, 0x01},
+	{0x11, 0x20},//AEC_out_slope , 0x
+	{0x1f, 0xc0},//max_post_gain
+	{0x20, 0x60},//max_pre_gain
+	{0x47, 0x30},//AEC_outdoor_th
+	{0x0b, 0x10},//
+	{0x13, 0x75},//y_target
+	{0xfe, 0x00},
+
+#if 0
+	{0x05 , 0x01},//hb
+	{0x06 , 0x11},
+	{0x07 , 0x00},//vb
+	{0x08 , 0x50},
+	{0xfe , 0x01},
+	{0x27 , 0x00},//step
+	{0x28 , 0xa0},
+	{0x29 , 0x05},//level1
+	{0x2a , 0x00},
+	{0x2b , 0x05},//level2
+	{0x2c , 0x00},
+	{0x2d , 0x06},//6e8//level3
+	{0x2e , 0xe0},
+	{0x2f , 0x0a},//level4
+	{0x30 , 0x00},
+	{0x3e , 0x40},
+#else
+	{0xfe , 0x00},  
+	{0x05 , 0x01},
+	{0x06 , 0x0d},  
+	{0x07 , 0x00},
+	{0x08 , 0x40},  
+	{0xfe , 0x01},  
+	{0x27 , 0x00},
+	{0x28 , 0xa0},  
+	{0x29 , 0x05},//  level 0 12.5
+	{0x2a , 0x00},  
+	{0x2b , 0x05},//  level 1 12.5
+	{0x2c , 0x00},  
+	{0x2d , 0x05},//  level 2 12.5 640/10fps
+	{0x2e , 0x00},  
+	{0x2f , 0x08},//  level 3 7.5
+	{0x30 , 0x20},  
+#endif
+
+	{0xfe , 0x00},
+	{0xfe , 0x00},  //0x , 0x , 0x , 0x , 0x 
+	{0xb6 , 0x03}, //AEC enable
+	{0xfe , 0x00},
+
+	/////////BLK//////
+	{0x3f, 0x00}, //prc close
+	{0x40, 0x77},//
+	{0x42, 0x7f},
+	{0x43, 0x30},
+	{0x5c, 0x08},
+	{0x5e, 0x20},
+	{0x5f, 0x20},
+	{0x60, 0x20},
+	{0x61, 0x20},
+	{0x62, 0x20},
+	{0x63, 0x20},
+	{0x64, 0x20},
+	{0x65, 0x20},
+	
+	///block////////////
+	{0x80, 0xff},
+	{0x81, 0x26},//38 , 0x//skin_Y 8c_debug
+	{0x87, 0x90}, //[7]middle gamma 
+	{0x84, 0x03}, //output put foramat
+	{0x86, 0x07}, ////sync plority  02 86
+	{0x8b, 0xbc},
+	{0xb0, 0x80}, //globle gain
+	{0xc0, 0x40},//Yuv bypass
+	
+	//////lsc/////////////
+#if 0
+	{0xfe, 0x01},
+	{0xc2, 0x38},
+	{0xc3, 0x25},
+	{0xc4, 0x21},
+	{0xc8, 0x19},
+	{0xc9, 0x12},
+	{0xca, 0x0e},
+	{0xbc, 0x28},// left R 0x43
+	{0xbd, 0x18},//0x18
+	{0xbe, 0x1b},//0x1b
+	{0xb6, 0x40},//right  0x40
+	{0xb7, 0x2e},
+	{0xb8, 0x26},
+	{0xc5, 0x05},
+	{0xc6, 0x03},
+	{0xc7, 0x04},
+	{0xcb, 0x00},
+	{0xcc, 0x00},
+	{0xcd, 0x00},
+	{0xbf, 0x14},
+	{0xc0, 0x22},
+	{0xc1, 0x1b},
+	{0xb9, 0x00},
+	{0xba, 0x05},
+	{0xbb, 0x05},
+	{0xaa, 0x35},
+	{0xab, 0x33},
+	{0xac, 0x33},
+	{0xad, 0x25},
+	{0xae, 0x22},
+	{0xaf, 0x27},
+	{0xb0, 0x1d},
+	{0xb1, 0x20},
+	{0xb2, 0x22},
+	{0xb3, 0x14},
+	{0xb4, 0x15},
+	{0xb5, 0x16},
+	{0xd0, 0x00},
+	{0xd2, 0x07},
+	{0xd3, 0x08},
+	{0xd8, 0x00},
+	{0xda, 0x13},
+	{0xdb, 0x17},
+	{0xdc, 0x00},
+	{0xde, 0x0a},
+	{0xdf, 0x08},
+	{0xd4, 0x00},
+	{0xd6, 0x00},
+	{0xd7, 0x0c},
+	{0xa4, 0x00},
+	{0xa5, 0x00},
+	{0xa6, 0x00},
+	{0xa7, 0x00},
+	{0xa8, 0x00},
+	{0xa9, 0x00},
+	{0xa1, 0x80},
+	{0xa2, 0x80},
+#else
+	//gc2035 Alight lsc reg setting list
+	////Record date: 2013-11-29 13:30:15
+	
+	{0xfe,0x01},
+	{0xc2,0x21},
+	{0xc3,0x1a},
+	{0xc4,0x13},
+	{0xc8,0x17},
+	{0xc9,0x0f},
+	{0xca,0x00},
+	{0xbc,0x36},
+	{0xbd,0x2b},
+	{0xbe,0x17},
+	{0xb6,0x39},
+	{0xb7,0x21},
+	{0xb8,0x1c},
+	{0xc5,0x00},
+	{0xc6,0x00},
+	{0xc7,0x00},
+	{0xcb,0x00},
+	{0xcc,0x0c},
+	{0xcd,0x15},
+	{0xbf,0x00},
+	{0xc0,0x00},
+	{0xc1,0x00},
+	{0xb9,0x00},
+	{0xba,0x00},
+	{0xbb,0x00},
+	{0xaa,0x15},
+	{0xab,0x15},
+	{0xac,0x15},
+	{0xad,0x14},
+	{0xae,0x13},
+	{0xaf,0x12},
+	{0xb0,0x1b},
+	{0xb1,0x14},
+	{0xb2,0x14},
+	{0xb3,0x1f},
+	{0xb4,0x12},
+	{0xb5,0x13},
+	{0xd0,0x00},
+	{0xd2,0x00},
+	{0xd3,0x0c},
+	{0xd8,0x00},
+	{0xda,0x00},
+	{0xdb,0x13},
+	{0xdc,0x00},
+	{0xde,0x00},
+	{0xdf,0x25},
+	{0xd4,0x00},
+	{0xd6,0x00},
+	{0xd7,0x12},
+	{0xa4,0x00},
+	{0xa5,0x00},
+	{0xa6,0x00},
+	{0xa7,0x00},
+	{0xa8,0x00},
+	{0xa9,0x00},
+	{0xa1,0x80},
+	{0xa2,0x80},
+#endif
 
+	//////////cc//////////////
+	{0xfe, 0x02},
+	{0xc0, 0x01},
+	{0xc1, 0x40}, //Green_cc for d
+	{0xc2, 0xfc},
+	{0xc3, 0x05},
+	{0xc4, 0xec},
+	{0xc5, 0x42},
+	{0xc6, 0xf8},
+	{0xc7, 0x40},//for cwf 
+	{0xc8, 0xf8},
+	{0xc9, 0x06},
+	{0xca, 0xfd},
+	{0xcb, 0x3e},
+	{0xcc, 0xf3},
+	{0xcd, 0x36},//for A
+	{0xce, 0xf6},
+	{0xcf, 0x04},
+	{0xe3, 0x0c},
+	{0xe4, 0x44},
+	{0xe5, 0xe5},
+	{0xfe, 0x00},
 
-	{0xfa , 0x00}, 
+	///////awb start ////////////////
+	//AWB clear
+	{0xfe, 0x01},
+	{0x4f, 0x00}, 
+	{0x4d, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0x10}, // 10
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0x20}, // 20
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},   
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0x30},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00}, // 30
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},  
+	{0x4e, 0x00},
+	{0x4e, 0x00},  
+	{0x4e, 0x00},
+	{0x4d, 0x40}, // 40
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},    
+	{0x4e, 0x00},      
+	{0x4e, 0x00},  
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0x50}, // 50
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},  
+	{0x4e, 0x00},  
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0x60}, // 60
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00}, 
+	{0x4e, 0x00}, 
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0x70}, // 70
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0x80}, // 80
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0x90}, // 90
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00}, 
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0xa0}, // a0
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00}, 
+	{0x4e, 0x00}, 
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0xb0}, // b0
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00}, 
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0xc0}, // c0
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00}, 
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00}, 
+	{0x4e, 0x00}, 
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4d, 0xd0}, // d0
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4e, 0x00},
+	{0x4f, 0x01},
+	/////// awb value////////
+	{0xfe, 0x01},
+	{0x4f, 0x00},
+	{0x4d, 0x30},
+	{0x4e, 0x00},
+	{0x4e, 0x80},
+	{0x4e, 0x80},
+	{0x4e, 0x02},
+	{0x4e, 0x02},
+	{0x4d, 0x40},
+	{0x4e, 0x00},
+	{0x4e, 0x80},
+	{0x4e, 0x80},
+	{0x4e, 0x02},
+	{0x4e, 0x02},
+	{0x4e, 0x02},
+	{0x4d, 0x53},
+	{0x4e, 0x08},
+	{0x4e, 0x04},
+	{0x4d, 0x62},
+	{0x4e, 0x10},
+	{0x4d, 0x72},
+	{0x4e, 0x20},
+	{0x4f, 0x01},
 
+	/////awb////
+	{0xfe, 0x01},
+	{0x50, 0x88},//c0//[6]green mode
+	{0x52, 0x40},
+	{0x54, 0x60},
+	{0x56, 0x06},
+	{0x57, 0x20}, //pre adjust
+	{0x58, 0x01}, 
+	{0x5b, 0x02}, //AWB_gain_delta
+	{0x61, 0xaa},//R/G stand
+	{0x62, 0xaa},//R/G stand
+	{0x71, 0x00},
+	{0x74, 0x10},  //0x//AWB_C_max
+	{0x77, 0x08}, // 0x//AWB_p2_x
+	{0x78, 0xfd}, //AWB_p2_y
+	{0x86, 0x30},
+	{0x87, 0x00},
+	{0x88, 0x04},//06 , 0x//[1]dark mode
+	{0x8a, 0xc0},//awb move mode
+	{0x89, 0x75},
+	{0x84, 0x08},  //0x//auto_window
+	{0x8b, 0x00}, // 0x//awb compare luma
+	{0x8d, 0x70}, //awb gain limit R 
+	{0x8e, 0x70},//G
+	{0x8f, 0xf4},//B
+	{0xfe, 0x00},
+	{0x82, 0x02},//awb_en
+    /////////awb end /////////////
+	
+	///==========asde
+	{0xfe, 0x01},
+	{0x21, 0xbf},
+	{0xfe, 0x02},
+	{0xa4, 0x00},//
+	{0xa5, 0x40}, //lsc_th
+	{0xa2, 0xa0}, //lsc_dec_slope
+	{0x86, 0x27},//add for DPC travis 20140505   
+	{0x8a, 0x33},//add for DPC travis 20140505 
+	{0x8d, 0x85},//add for DPC travis 20140505 
+	{0xa6, 0xf0},//80//change for DPC travis 20140505
+	{0xa7, 0x80}, //ot_th
+	{0xab, 0x31}, //
+	{0xa9, 0x6f}, //
+	{0xb0, 0x99}, //0x//edge effect slope low
+	{0xb1, 0x34},//edge effect slope low
+	{0xb3, 0x80}, //saturation dec slope
+	{0xde, 0xb6},  //
+	{0x38, 0x0f}, // 
+	{0x39, 0x60}, //
+	{0xfe, 0x00},
+	{0x81, 0x26},
+	{0xfe, 0x02},
+	{0x83, 0x00},//
+	{0x84, 0x45},//
+	////////////YCP//////////
+	{0xd1, 0x38},//saturation_cb
+	{0xd2, 0x38},//saturation_Cr
+	{0xd3, 0x40},//contrast ?
+	{0xd4, 0x80},//contrast center 
+	{0xd5, 0x00},//luma_offset 
+	{0xdc, 0x30},
+	{0xdd, 0xb8},  //edge_sa_g,b
+	{0xfe, 0x00}, 
+	///////dndd///////////
+	{0xfe, 0x02},  
+	{0x88, 0x15},//dn_b_base
+	{0x8c, 0xf6}, //[2]b_in_dark_inc
+	{0x89, 0x03}, //dn_c_weight
+	////////EE ///////////
+	{0xfe, 0x02}, 
+	{0x90, 0x6c},// EEINTP mode1
+	{0x97, 0x45},// edge effect
+	////==============RGB Gamma 
+	{0xfe, 0x02},  
+	{0x15, 0x0a},
+	{0x16, 0x12},
+	{0x17, 0x19},
+	{0x18, 0x1f},
+	{0x19, 0x2c},
+	{0x1a, 0x38},
+	{0x1b, 0x42},
+	{0x1c, 0x4e},
+	{0x1d, 0x63},
+	{0x1e, 0x76},
+	{0x1f, 0x87},
+	{0x20, 0x96},
+	{0x21, 0xa2},
+	{0x22, 0xb8},
+	{0x23, 0xca},
+	{0x24, 0xd8},
+	{0x25, 0xe3},
+	{0x26, 0xf0},
+	{0x27, 0xf8},
+	{0x28, 0xfd},
+	{0x29, 0xff},  
+	
+	///=================y gamma
+	{0xfe, 0x02},
+	{0x2b, 0x00},
+	{0x2c, 0x04},
+	{0x2d, 0x09},
+	{0x2e, 0x18},
+	{0x2f, 0x27},
+	{0x30, 0x37},
+	{0x31, 0x49},
+	{0x32, 0x5c},
+	{0x33, 0x7e},
+	{0x34, 0xa0},
+	{0x35, 0xc0},
+	{0x36, 0xe0},
+	{0x37, 0xff},
+	/////1600x1200size// 
+	{0xfe, 0x00},//
+	{0x90, 0x01}, //0x//crop enable
+	{0x95, 0x04},  //0x//1600x1200
+	{0x96, 0xb0},
+	{0x97, 0x06},
+	{0x98, 0x40},
+	
+	{0xfe, 0x03},
+	{0x42, 0x40}, 
+	{0x43, 0x06}, //output buf width
+	{0x41, 0x02}, // Pclk_polarity
+	{0x40, 0x40},  //00  
+	{0x17, 0x00}, //widv 
+	{0xfe, 0x00},
+	////output DVP/////
+	{0xfe , 0x00},
+	{0xb6 , 0x03},
+	{0xfa , 0x00},
 
-	{0xfe , 0x03},
-	{0x42 , 0x00}, 
-	{0x43 , 0x05}, //output buf width  280*2=500
-	{0x41 , 0x02}, // delay
-	{0x40 , 0x40}, //fifo half full trig
-	{0x17 , 0x00}, //widv is 0
+	{0xc8, 0x00},//close scaler
+	{0x99, 0x22},// 1/2 subsample
+	{0x9a, 0x06},
+	{0x9b, 0x00},
+	{0x9c, 0x00},
+	{0x9d, 0x00},
+	{0x9e, 0x00},
+	{0x9f, 0x00},
+	{0xa0, 0x00},  
+	{0xa1, 0x00},
+	{0xa2, 0x00},
+	
+	{0x90, 0x01},  //crop enable
+	{0x94, 0x02},
+	{0x95, 0x02},
+	{0x96, 0x5a},
+	{0x97, 0x03},
+	{0x98, 0x20},
+	{0xfe, 0x00},
+	{0x82, 0xfe},  // fe
+	{0xf2, 0x70},
+	{0xf3, 0xff},
+	{0xf4, 0x00},
+	{0xf5, 0x30},
+	
+#if 0   
+    /////////  re zao///
+	{0xfe,0x00},
+	{0x22,0xf0},
+	{0xfe,0x01},
+	{0x21,0xff},
+	{0xfe,0x02},  
+	{0x8a,0x33},
+	{0x8c,0x76},
+	{0x8d,0x85},
+	{0xa6,0xf0},	
+	{0xae,0x9f},
+	{0xa2,0x90},
+	{0xa5,0x40},  
+	{0xa7,0x30},
+	{0xb0,0x88},
+	{0x38,0x0b},
+	{0x39,0x30},
+	{0xfe,0x00},  
+	{0x87,0xb0},
 
-	{0xfe , 0x00},
-	{0xc8 , 0x55}, 
-	{0xb6 , 0x03},//aec on
+       //// small  RGB gamma////
+	{0xfe, 0x02},
+	{0x15, 0x0b},
+	{0x16, 0x0e},
+	{0x17, 0x10},
+	{0x18, 0x12},
+	{0x19, 0x19},
+	{0x1a, 0x21},
+	{0x1b, 0x29},
+	{0x1c, 0x31},
+	{0x1d, 0x41},
+	{0x1e, 0x50},
+	{0x1f, 0x5f},
+	{0x20, 0x6d},
+	{0x21, 0x79},
+	{0x22, 0x91},
+	{0x23, 0xa5},
+	{0x24, 0xb9},
+	{0x25, 0xc9},
+	{0x26, 0xe1},
+	{0x27, 0xee},
+	{0x28, 0xf7},
+	{0x29, 0xff},
+	
+ 	////dark sun/////
+	{0xfe, 0x02},
+	{0x40, 0x06},
+	{0x41, 0x23},
+	{0x42, 0x3f},
+	{0x43, 0x06},
+	{0x44, 0x00},
+	{0x45, 0x00},
+	{0x46, 0x14},
+	{0x47, 0x09},
+#endif
+#ifdef Auto_LSC_debug
+  {0xfe , 0x00},
+  {0x80 , 0x08},
+  {0x81 , 0x00},
+  {0x82 , 0x00},
+  {0xa3 , 0x80},
+  {0xa4 , 0x80},
+  {0xa5 , 0x80},
+  {0xa6 , 0x80},
+  {0xa7 , 0x80},
+  {0xa8 , 0x80},
+  {0xa9 , 0x80},
+  {0xaa , 0x80},
+  {0xad , 0x80},
+  {0xae , 0x80},
+  {0xaf , 0x80},
+  {0xb3 , 0x40},
+  {0xb4 , 0x40},
+  {0xb5 , 0x40},
+  {0xfe , 0x01},
+  {0x0a , 0x40},
+  {0x13 , 0x48},
+  {0x9f , 0x40},
+  {0xfe , 0x02},
+  {0xd0 , 0x40},
+  {0xd1 , 0x20},
+  {0xd2 , 0x20},
+  {0xd3 , 0x40},
+  {0xd5 , 0x00},
+  {0xdd , 0x00},
+  {0xfe , 0x00},
+#endif    
 };
 
-
-////1280*720---init---///
-static struct regval_list Gc2015_sensor_hd720_regs[] = 
+/* 1600x1200 UXGA,5fps*/
+static struct regval_list sensor_uxga_regs_hres3[] =
 {
-{0xfe , 0x00},
-{0x05, 0x01},
-{0x06, 0x9e},
-{0x07, 0x01},
-{0x08, 0x6d},  
-{0x0a , 0xf0}, //row start
-{0x0c , 0xa0}, //col start 
-{0x0d , 0x02},
-{0x0e , 0xd8},
-{0x0f , 0x05}, //Window setting
-{0x10 , 0x18},   
-
-{0xfe, 0x01},
-{0x27, 0x00},
-{0x28, 0xd9},
-{0x29, 0x04},
-{0x2a, 0x3d},//18fps
-{0x2b, 0x06},
-{0x2c, 0xc8},//12.5fps
-{0x2d, 0x0a},
-{0x2e, 0x2c},//8fps
-{0x3e, 0x40},//0x40 0x00
-
-//measure window
-{0xfe, 0x00},
-{0xec, 0x04},
-{0xed, 0x04},
-{0xee, 0x50},
-{0xef, 0x58},
-
-{0x90 , 0x01},  //crop enable
-{0x95 , 0x02},
-{0x96 , 0xd0},
-{0x97 , 0x05},
-{0x98 , 0x00},   
-
-
-{0xfe , 0x03},
-{0x42 , 0x80}, 
-{0x43 , 0x06}, //output buf width
-{0x41 , 0x00}, // delay
-{0x40 , 0x00}, //fifo half full trig
-{0x17 , 0x01}, //widv 
-{0xfe , 0x00},
+};
 
-{0x99, 0x11},
-{0xc8, 0x00},
+/* 800x600 SVGA,15fps*/
+static struct regval_list sensor_svga_regs_hres3[] =
+{
+};
 
-{0xfa, 0x11},
 
-{0xff, 0xff},
+/* 640x480 VGA,15fps*/
+static struct regval_list sensor_vga_regs_hres3[] =
+{
+};
 
+/* 352x288 CIF,15fps*/
+static struct regval_list sensor_cif_regs_hres3[] =
+{
 };
 
 
+/* 320x240 QVGA,15fps*/
+static struct regval_list sensor_qvga_regs_hres3[] =
+{
+};
+#endif
 
 /*
  * The white balance settings
@@ -2311,6 +3941,8 @@ static int sensor_write_array(struct v4l
 	
   if(!regs)
   	return -EINVAL;
+  if (!array_size)
+      return 0;
   
   while(i<array_size)
   {
@@ -2894,7 +4526,7 @@ static int sensor_power(struct v4l2_subd
 		vfe_gpio_write(sd,PWDN, CSI_GPIO_LOW);
 		usleep_range(10000,12000);
 		//active mclk before stadby out
-		vfe_set_mclk_freq(sd,MCLK);
+		vfe_set_mclk_freq(sd,nMCLK);
 		vfe_set_mclk(sd,ON);
 		usleep_range(10000,12000);
 		vfe_dev_print("enable oe!\n");
@@ -2906,7 +4538,7 @@ static int sensor_power(struct v4l2_subd
 		vfe_dev_dbg("CSI_SUBDEV_PWR_ON\n");
 		vfe_gpio_set_status(sd,PWDN,1);//set the gpio to output
 		vfe_gpio_set_status(sd,RESET,1);//set the gpio to output
-		vfe_set_mclk_freq(sd,MCLK);
+		vfe_set_mclk_freq(sd,nMCLK);
 		vfe_set_mclk(sd,ON);
 		vfe_gpio_write(sd,PWDN, CSI_GPIO_LOW);
 		vfe_gpio_write(sd,RESET, CSI_GPIO_LOW);
@@ -2999,20 +4631,6 @@ static int sensor_detect(struct v4l2_sub
 	return 0;
 }
 
-static int sensor_init(struct v4l2_subdev *sd, u32 val)
-{
-	int ret;
-	vfe_dev_dbg("sensor_init\n");
-	/*Make sure it is a target sensor*/
-	ret = sensor_detect(sd);
-	if (ret) {
-		vfe_dev_err("chip found is not an target chip.\n");
-		return ret;
-	}
-	ret = sensor_write_array(sd, sensor_default_regs , ARRAY_SIZE(sensor_default_regs));
-	msleep(350);
-    return 0;
-}
 
 static int sensor_g_exif(struct v4l2_subdev *sd, struct sensor_exif_attribute *exif)
 {
@@ -3111,18 +4729,16 @@ static struct sensor_format_struct {
 /*
  * Then there is the issue of window sizes.  Try to capture the info here.
  */
-
-
 static struct sensor_win_size 
-sensor_win_sizes[] = {
+sensor_win_sizes_hres0[] = {
   /* UXGA */
   {
     .width      = UXGA_WIDTH,
     .height     = UXGA_HEIGHT,
     .hoffset    = 0,
     .voffset    = 0,
-    .regs       = sensor_uxga_regs,
-    .regs_size  = ARRAY_SIZE(sensor_uxga_regs),
+    .regs       = sensor_uxga_regs_hres0,
+    .regs_size  = ARRAY_SIZE(sensor_uxga_regs_hres0),
     .set_size   = NULL,
   },
   /* 720p */
@@ -3131,8 +4747,103 @@ sensor_win_sizes[] = {
     .height     = HD720_HEIGHT,
     .hoffset    = 0,
     .voffset    = 0,
-		.regs		= Gc2015_sensor_hd720_regs,
-		.regs_size	= ARRAY_SIZE(Gc2015_sensor_hd720_regs),
+		.regs		= Gc2015_sensor_hd720_regs_hres0,
+		.regs_size	= ARRAY_SIZE(Gc2015_sensor_hd720_regs_hres0),
+    .set_size   = NULL,
+  },
+  /* VGA */
+  {
+    .width      = VGA_WIDTH,
+    .height     = VGA_HEIGHT,
+    .hoffset    = 0,
+    .voffset    = 0,
+    .regs       = sensor_vga_regs_hres0,
+    .regs_size  = ARRAY_SIZE(sensor_vga_regs_hres0),
+    .set_size   = NULL,
+  },
+};
+
+static struct sensor_win_size 
+sensor_win_sizes_hres1[] = {
+  /* UXGA */
+  {
+    .width      = UXGA_WIDTH,
+    .height     = UXGA_HEIGHT,
+    .hoffset    = 0,
+    .voffset    = 0,
+    .regs       = sensor_uxga_regs_hres1,
+    .regs_size  = ARRAY_SIZE(sensor_uxga_regs_hres1),
+    .set_size   = NULL,
+  },
+  /* SVGA */
+  {
+    .width      = SVGA_WIDTH,
+    .height     = SVGA_HEIGHT,
+    .hoffset    = 0,
+    .voffset    = 0,
+    .regs       = sensor_svga_regs_hres1,
+    .regs_size  = ARRAY_SIZE(sensor_svga_regs_hres1),
+    .set_size   = NULL,
+  },
+
+};
+
+static struct sensor_win_size 
+sensor_win_sizes_hres2[] = {
+  /* UXGA */
+  {
+    .width      = UXGA_WIDTH,
+    .height     = UXGA_HEIGHT,
+    .hoffset    = 0,
+    .voffset    = 0,
+    .regs       = sensor_uxga_regs_hres2,
+    .regs_size  = ARRAY_SIZE(sensor_uxga_regs_hres2),
+    .set_size   = NULL,
+  },
+  /* SVGA */
+  {
+    .width      = SVGA_WIDTH,
+    .height     = SVGA_HEIGHT,
+    .hoffset    = 0,
+    .voffset    = 0,
+    .regs       = sensor_svga_regs_hres2,
+    .regs_size  = ARRAY_SIZE(sensor_svga_regs_hres2),
+    .set_size   = NULL,
+  },
+  /* VGA */
+  {
+    .width      = VGA_WIDTH,
+    .height     = VGA_HEIGHT,
+    .hoffset    = 0,
+    .voffset    = 0,
+    .regs       = sensor_vga_regs_hres2,
+    .regs_size  = ARRAY_SIZE(sensor_vga_regs_hres2),
+    .set_size   = NULL,
+  },
+  /* QVGA */
+  {
+    .width      = QVGA_WIDTH,
+    .height     = QVGA_HEIGHT,
+    .hoffset    = 0,
+    .voffset    = 0,
+    .regs       = sensor_qvga_regs_hres2,
+    .regs_size  = ARRAY_SIZE(sensor_qvga_regs_hres2),
+    .set_size   = NULL,
+  },
+
+};
+
+#if 1
+static struct sensor_win_size 
+sensor_win_sizes_hres3[] = {
+  /* UXGA */
+  {
+    .width      = UXGA_WIDTH,
+    .height     = UXGA_HEIGHT,
+    .hoffset    = 0,
+    .voffset    = 0,
+    .regs       = sensor_uxga_regs_hres3,
+    .regs_size  = ARRAY_SIZE(sensor_uxga_regs_hres3),
     .set_size   = NULL,
   },
   /* SVGA */
@@ -3141,8 +4852,8 @@ sensor_win_sizes[] = {
     .height     = SVGA_HEIGHT,
     .hoffset    = 0,
     .voffset    = 0,
-    .regs       = sensor_svga_regs,
-    .regs_size  = ARRAY_SIZE(sensor_svga_regs),
+    .regs       = sensor_svga_regs_hres3,
+    .regs_size  = ARRAY_SIZE(sensor_svga_regs_hres3),
     .set_size   = NULL,
   },
   /* VGA */
@@ -3151,13 +4862,34 @@ sensor_win_sizes[] = {
     .height     = VGA_HEIGHT,
     .hoffset    = 0,
     .voffset    = 0,
-    .regs       = sensor_vga_regs,
-    .regs_size  = ARRAY_SIZE(sensor_vga_regs),
+    .regs       = sensor_vga_regs_hres3,
+    .regs_size  = ARRAY_SIZE(sensor_vga_regs_hres3),
+    .set_size   = NULL,
+  },
+  /* CIF */
+  {
+    .width      = CIF_WIDTH,
+    .height     = CIF_HEIGHT,
+    .hoffset    = 0,
+    .voffset    = 0,
+    .regs       = sensor_cif_regs_hres3,
+    .regs_size  = ARRAY_SIZE(sensor_qvga_regs_hres3),
+    .set_size   = NULL,
+  },  
+  /* QVGA */
+  {
+    .width      = QVGA_WIDTH,
+    .height     = QVGA_HEIGHT,
+    .hoffset    = 0,
+    .voffset    = 0,
+    .regs       = sensor_qvga_regs_hres3,
+    .regs_size  = ARRAY_SIZE(sensor_qvga_regs_hres3),
     .set_size   = NULL,
   },
 };
+#endif
 
-#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))
+int nN_WIN_SIZES;   //  (ARRAY_SIZE(sensor_win_sizes))
 
 static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
                  enum v4l2_mbus_pixelcode *code)
@@ -3172,12 +4904,14 @@ static int sensor_enum_fmt(struct v4l2_s
 static int sensor_enum_size(struct v4l2_subdev *sd,
                             struct v4l2_frmsizeenum *fsize)
 {
-  if(fsize->index > N_WIN_SIZES-1)
+  if(fsize->index > nN_WIN_SIZES-1)
+  	return -EINVAL;
+  if(!sensor_win_sizes_ptr)
   	return -EINVAL;
   
   fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-  fsize->discrete.width = sensor_win_sizes[fsize->index].width;
-  fsize->discrete.height = sensor_win_sizes[fsize->index].height;
+  fsize->discrete.width = sensor_win_sizes_ptr[fsize->index].width;
+  fsize->discrete.height = sensor_win_sizes_ptr[fsize->index].height;
   
   return 0;
 }
@@ -3211,13 +4945,13 @@ static int sensor_try_fmt_internal(struc
    * Round requested image size down to the nearest
    * we support, but not below the smallest.
    */
-  for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
-       wsize++)
-    if (fmt->width >= wsize->width && fmt->height >= wsize->height)
-      break;
+  for (wsize = sensor_win_sizes_ptr; wsize < sensor_win_sizes_ptr + nN_WIN_SIZES; wsize++) {
+        if (fmt->width >= wsize->width && fmt->height >= wsize->height)
+            break;
+  }
     
-  if (wsize >= sensor_win_sizes + N_WIN_SIZES)
-    wsize--;   /* Take the smallest one */
+  if (wsize >= sensor_win_sizes_ptr + nN_WIN_SIZES)
+        wsize--;   /* Take the smallest one */
   if (ret_wsize != NULL)
     *ret_wsize = wsize;
   /*
@@ -3248,6 +4982,9 @@ static int sensor_g_mbus_config(struct v
 /*
  * Set a format.
  */
+static unsigned char shutter_l = 0;
+static unsigned char shutter_h = 0;
+
 static int sensor_s_fmt(struct v4l2_subdev *sd, 
              struct v4l2_mbus_framefmt *fmt)//linux-3.0
 {
@@ -3267,25 +5004,30 @@ static int sensor_s_fmt(struct v4l2_subd
 	if (ret)
 		return ret;
 
-#ifndef _640x480_1280x720_ONLY
-	if((wsize->width==1600)&&(wsize->height==1200))  //capture mode  >640*480
-	{
-		//	printk(" read  2035 exptime 11111111\n" );
-		sensor_write(sd, 0xfe, 0x00);
-		sensor_write(sd, 0xb6, 0x02);
-		/*read shutter */
-		sensor_read(sd, 0x03, &val);
-		temp |= (val<< 8);
-         //     printk(" read   0x03 = [%x]\n", regs.value[0]);	
-			  
-		sensor_read(sd, 0x04, &val);
-		temp |= (val & 0xff);
-	//	  printk(" read   0x04 = [%x]\n", regs.value[0]);
-		  
-		shutter=temp;
-	//	printk(" shutter = [%x]\n", shutter);		
-	}
-#endif
+#if 0
+    if (hres == 0)  {
+        if ((wsize->width == VGA_WIDTH) && (wsize->height == VGA_HEIGHT)) {
+            nMCLK = (34*1000*1000);
+            nSENSOR_FRAME_RATE = 25;
+        }
+    }
+#endif    
+    if (hres == 1 || hres == 2)  {
+        if ((wsize->width == UXGA_WIDTH) && (wsize->height == UXGA_HEIGHT)) {
+            //	printk(" read  2035 exptime 11111111\n" );
+            sensor_write(sd, 0xfe, 0x00);
+            sensor_write(sd, 0xb6, 0x02);
+            /*read shutter */
+            sensor_read(sd, 0x03, &val);
+            temp |= (val<< 8);
+            // printk(" read   0x03 = [%x]\n", regs.value[0]);	
+            sensor_read(sd, 0x04, &val);
+            temp |= (val & 0xff);
+            // printk(" read   0x04 = [%x]\n", regs.value[0]);
+            shutter=temp;
+            //	printk(" shutter = [%x]\n", shutter);		
+        }
+    }
 
 	sensor_write_array(sd, sensor_fmt->regs , sensor_fmt->regs_size);
 
@@ -3306,49 +5048,118 @@ static int sensor_s_fmt(struct v4l2_subd
 
  //////////
 
- #if 1
-
-#ifdef _640x480_1280x720_ONLY
-       if((wsize->width==1600)&&(wsize->height==1200))  {
-
-           sensor_write(sd, 0xfe, 0x00);
-	   sensor_write(sd, 0xb6, 0x02);  // AEC OFF
-	   sensor_read(sd, 0x03, &val);
-           temp |= (val<< 8);
-           sensor_read(sd, 0x04, &val);
-	   temp |= (val & 0xff);
-	   shutter=temp;
-	   shutter= shutter /2;	// 2
-  	   if (shutter < 1) 
+#if 1
+    if (hres == 0) {
+       if ((wsize->width == UXGA_WIDTH) && (wsize->height == UXGA_HEIGHT))  {
+            sensor_write(sd, 0xfe, 0x00);
+            sensor_write(sd, 0xb6, 0x02);  // AEC OFF
+            sensor_read(sd, 0x03, &val);
+            temp |= (val<< 8);
+            sensor_read(sd, 0x04, &val);
+            temp |= (val & 0xff);
+            shutter=temp;
+            shutter= shutter /2;	// 2
+            if (shutter < 1) 
                shutter = 1;
-	   val = ((shutter>>8)&0xff); 
-	   sensor_write(sd, 0x03, val);
-	   val = (shutter&0xff); 
-	   sensor_write(sd, 0x04, val);	
-	   msleep(550);
+            val = ((shutter>>8)&0xff); 
+            sensor_write(sd, 0x03, val);
+            val = (shutter&0xff); 
+            sensor_write(sd, 0x04, val);	
+            // msleep(550);
         }
-#else
-	if((wsize->width==1600)&&(wsize->height==1200))
-	{
-	//printk(" write  2035 exptime 22222222\n" );
-	sensor_write(sd, 0xfe, 0x00);
-	shutter= shutter /2;	// 2
-	if(shutter < 1) shutter = 1;
-	val = ((shutter>>8)&0xff); 
-     //  printk(" write0x03 = [%x]\n", regs.value[0]);
-	sensor_write(sd, 0x03, val);
-	val = (shutter&0xff); 
-	sensor_write(sd, 0x04, val);	
-	msleep(550);
-	}
-#endif
-	if((wsize->width==640)&&(wsize->height==480)) {
+    }
+    if (hres == 1) {
+        if((wsize->width == UXGA_WIDTH) && (wsize->height == UXGA_HEIGHT))     {
+            //printk(" write  2035 exptime 22222222\n" );
+            sensor_write(sd, 0xfe, 0x00);
+            shutter= shutter / 2;	// 2
+            if(shutter < 1)
+               shutter = 1;
+            val = ((shutter>>8)&0xff); 
+             //  printk(" write0x03 = [%x]\n", regs.value[0]);
+            sensor_write(sd, 0x03, val);
+            val = (shutter&0xff); 
+            sensor_write(sd, 0x04, val);	
+            msleep(550);
+        }
+    }
+    if (hres == 0) {
+        if( (wsize->width == VGA_WIDTH && wsize->height == VGA_HEIGHT) || (wsize->width == HD720_WIDTH && wsize->height == HD720_HEIGHT)) {
              mdelay(50);//200
-	     sensor_write(sd, 0xb6, 0x03);  // AEC ON
-	     mdelay(300);
+             sensor_write(sd, 0xb6, 0x03);  // AEC ON
+             mdelay(300);
+             nSENSOR_FRAME_RATE = 8;
         }
-
- 
+    }
+    if (hres == 3) {
+        if ((wsize->width >= UXGA_WIDTH) && (wsize->height >= UXGA_HEIGHT))     {
+            sensor_write(sd, 0xfe, 0x01);
+            sensor_write(sd, 0x21, 0xdf);
+            sensor_write(sd, 0xfe, 0x00);
+            sensor_write(sd, 0xb6, 0x02);  // AEC OFF
+            sensor_read(sd, 0x03, &val);
+            shutter_l = val;
+            temp |= (val<< 8);
+            sensor_read(sd, 0x04, &val);
+            shutter_h = val;
+            temp |= (val & 0xff);
+            shutter=temp;
+            sensor_write(sd, 0xfe, 0x00);
+            sensor_write(sd, 0xc8, 0x00);
+            sensor_write(sd, 0xfa, 0x11);
+            sensor_write(sd, 0x90, 0x01);
+            sensor_write(sd, 0x95, 0x04);
+            sensor_write(sd, 0x96, 0xb2);
+            sensor_write(sd, 0x97, 0x06);
+            sensor_write(sd, 0x98, 0x40);
+            sensor_write(sd, 0x99, 0x11);
+            sensor_write(sd, 0x9a, 0x06);
+            sensor_write(sd, 0x9b, 0x00);
+            sensor_write(sd, 0x9e, 0x00);
+            sensor_write(sd, 0xa0, 0x00);
+            sensor_write(sd, 0xa1, 0x00);
+            sensor_write(sd, 0xa2, 0x00);
+            shutter= shutter / 2;	// 2
+            if(shutter < 1)
+               shutter = 1;
+            val = ((shutter>>8)&0xff); 
+             //  printk(" write0x03 = [%x]\n", regs.value[0]);
+            sensor_write(sd, 0x03, val);
+            val = (shutter&0xff); 
+            sensor_write(sd, 0x04, val);
+            nSENSOR_FRAME_RATE = 8;
+            mdelay(130);
+        } else {
+            sensor_write(sd, 0xfe, 0x01);
+            sensor_write(sd, 0x21, 0xbf);
+            sensor_write(sd, 0xfe, 0x00);
+            
+            sensor_write(sd, 0x03, shutter_l);
+            sensor_write(sd, 0x04, shutter_h);
+
+            sensor_write(sd, 0xb6, 0x03);
+            sensor_write(sd, 0xfa, 0x00);
+            sensor_write(sd, 0xc8, 0x00);
+            sensor_write(sd, 0x99, 0x22);
+            sensor_write(sd, 0x9a, 0x07);
+            sensor_write(sd, 0x9b, 0x00);
+            sensor_write(sd, 0x9c, 0x00);
+            sensor_write(sd, 0x9d, 0x00);
+            sensor_write(sd, 0x9e, 0x00);
+            sensor_write(sd, 0x9f, 0x00);
+
+            sensor_write(sd, 0xa1, 0x00);
+            sensor_write(sd, 0xa2, 0x00);
+            sensor_write(sd, 0x90, 0x01); // crop enable
+            sensor_write(sd, 0x94, 0x02);
+            sensor_write(sd, 0x95, 0x02);
+            sensor_write(sd, 0x96, 0x5a);
+            sensor_write(sd, 0x97, 0x03);
+            sensor_write(sd, 0x98, 0x22);
+            nSENSOR_FRAME_RATE = 15;
+            mdelay(50);
+        }
+    }
 #endif	
 /////////////////////////////
 
@@ -3377,53 +5188,55 @@ static int sensor_g_parm(struct v4l2_sub
 	memset(cp, 0, sizeof(struct v4l2_captureparm));
 	cp->capability = V4L2_CAP_TIMEPERFRAME;
 	cp->timeperframe.numerator = 1;
-	
-	if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
-		cp->timeperframe.denominator = SENSOR_FRAME_RATE/2;
-	} 
-	else {
-		cp->timeperframe.denominator = SENSOR_FRAME_RATE;
-	}
+
+    cp->timeperframe.denominator = nSENSOR_FRAME_RATE;
+    if (hres < 2) {
+        if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+            cp->timeperframe.denominator = nSENSOR_FRAME_RATE/2;
+        }
+    } else {
+        if (hres == 3) {
+            if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+                cp->timeperframe.denominator = 5;
+            }
+        }
+    }
 	
 	return 0;
 }
 
 static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
 {
-//	struct v4l2_captureparm *cp = &parms->parm.capture;
-//	struct v4l2_fract *tpf = &cp->timeperframe;
-//	struct sensor_info *info = to_state(sd);
-//	int div;
-
-//	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-//		return -EINVAL;
-//	if (cp->extendedmode != 0)
-//		return -EINVAL;
-
-//	if (tpf->numerator == 0 || tpf->denominator == 0)
-//		div = 1;  /* Reset to full rate */
-//	else {
-//		if (info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
-//			div = (tpf->numerator*SENSOR_FRAME_RATE/2)/tpf->denominator;
-//		}
-//		else {
-//			div = (tpf->numerator*SENSOR_FRAME_RATE)/tpf->denominator;
-//		}
-//	}	
-//	
-//	if (div == 0)
-//		div = 1;
-//	else if (div > 8)
-//		div = 8;
-//	
-//	switch()
-//	
-//	info->clkrc = (info->clkrc & 0x80) | div;
-//	tpf->numerator = 1;
-//	tpf->denominator = sensor_FRAME_RATE/div;
-//	
-//	sensor_write(sd, REG_CLKRC, info->clkrc);
-	//return -EINVAL;
+  	struct v4l2_captureparm *cp = &parms->parm.capture;
+  	struct v4l2_fract *tpf = &cp->timeperframe;
+  	struct sensor_info *info = to_state(sd);
+  	int div;
+    int clkrc;
+
+  	if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+  		return -EINVAL;
+  	if (cp->extendedmode != 0)
+  		return -EINVAL;
+
+  	if (tpf->numerator == 0 || tpf->denominator == 0)
+  		div = 1;  /* Reset to full rate */
+  	else {
+        div = (tpf->numerator*nSENSOR_FRAME_RATE)/tpf->denominator;
+  		if (hres < 2 && info->width > SVGA_WIDTH && info->height > SVGA_HEIGHT) {
+            div = (tpf->numerator*nSENSOR_FRAME_RATE/2)/tpf->denominator;
+  		}
+  	}	
+  	
+  	if (div == 0)
+  		div = 1;
+  	else if (div > 8)
+  		div = 8;
+    clkrc = 1;
+  	clkrc = (clkrc & 0x80) | div;
+  	tpf->numerator = 1;
+  	tpf->denominator = nSENSOR_FRAME_RATE/div;
+  	
+  	sensor_write(sd, REG_CLKRC, clkrc);
 	return 0;
 }
 
@@ -3645,6 +5458,54 @@ static int sensor_g_chip_ident(struct v4
 	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
 }
 
+static int sensor_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret, nsize;
+	vfe_dev_dbg("sensor_init\n");
+	/*Make sure it is a target sensor*/
+	ret = sensor_detect(sd);
+	if (ret) {
+		vfe_dev_err("chip found is not an target chip.\n");
+		return ret;
+	}
+    sensor_win_sizes_ptr = sensor_win_sizes_hres0;
+    nN_WIN_SIZES = (ARRAY_SIZE(sensor_win_sizes_hres0));
+    sensor_default_regs_ptr = sensor_default_regs_hres0;
+    if (hres == 1) {
+        nN_WIN_SIZES = (ARRAY_SIZE(sensor_win_sizes_hres1));
+        sensor_win_sizes_ptr = sensor_win_sizes_hres1;
+        sensor_default_regs_ptr = sensor_default_regs_hres1;
+    } else {
+        if (hres == 2) {
+            nN_WIN_SIZES = (ARRAY_SIZE(sensor_win_sizes_hres2));
+            sensor_win_sizes_ptr = sensor_win_sizes_hres2;
+            sensor_default_regs_ptr = sensor_default_regs_hres2;
+        } else {
+            if (hres == 3) {
+                nN_WIN_SIZES = (ARRAY_SIZE(sensor_win_sizes_hres3));
+                sensor_win_sizes_ptr = sensor_win_sizes_hres3;
+                sensor_default_regs_ptr = sensor_default_regs_hres3;
+            }
+        }
+    }
+    nsize = ARRAY_SIZE(sensor_default_regs_hres0);
+    if (hres == 1) {
+        nsize = ARRAY_SIZE(sensor_default_regs_hres1);
+    } else {
+        if (hres == 2) {
+            nsize = ARRAY_SIZE(sensor_default_regs_hres2);
+        } else {
+            if (hres == 3) {
+                nsize = ARRAY_SIZE(sensor_default_regs_hres3);
+            }
+        }
+    }
+	ret = sensor_write_array(sd, sensor_default_regs_ptr , nsize);
+	msleep(350);
+    return 0;
+}
+
+
 
 /* ----------------------------------------------------------------------- */
 
@@ -3686,7 +5547,6 @@ static int sensor_probe(struct i2c_clien
 {
 	struct v4l2_subdev *sd;
 	struct sensor_info *info;
-//	int ret;
 
 	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
 	if (info == NULL)
@@ -3712,7 +5572,7 @@ static int sensor_probe(struct i2c_clien
 	info->autowb = 1;
 	info->wb = 0;
 	info->clrfx = 0;
-//	info->clkrc = 1;	/* 30fps */
+    //	info->clkrc = 1;	/* 30fps */
 
 	return 0;
 }
@@ -3745,6 +5605,22 @@ static struct i2c_driver sensor_driver =
 };
 static __init int init_sensor(void)
 {
+    nMCLK = (24*1000*1000);
+    if (mclk && mclk < 35) {
+        nMCLK = (mclk*1000*1000);
+    }
+    nSENSOR_FRAME_RATE = 8;
+    if (hres == 2) {
+        nMCLK = (34*1000*1000);
+        nSENSOR_FRAME_RATE = 20;
+    } else {
+        if (hres == 3) {
+            nSENSOR_FRAME_RATE = 15;
+        }
+    }
+    if (frate) {
+        nSENSOR_FRAME_RATE = frate;
+    }
 	return cci_dev_init_helper(&sensor_driver);
 }
 
@@ -3755,4 +5631,3 @@ static __exit void exit_sensor(void)
 
 module_init(init_sensor);
 module_exit(exit_sensor);
-
